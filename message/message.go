package message

import (
	"fmt"
	"log"
	"strings"
)

// input: the message as it is recieved on each satelite
// output: the message as it is generated by the transmitter
func GetMessage(messages ...[]string) (msg string) {
	var err error
	msg, err = ConsolidateMessage(messages)
	if err != nil {
		log.Printf("Is no possible to compelete calculations. %s", err.Error())
	}
	return msg
}

// Builds consolidation message
// input: the diferent sources of messages list
// outpur: the complete message
func ConsolidateMessage(messages [][]string) (completeMessage string, err error) {
	// get coutn messages
	countMessages := len(messages)

	// get count words of the full message
	countWords := 0
	for _, message := range messages {
		msgLength := len(message)
		if countWords < msgLength {
			countWords = msgLength
		}
	}

	// autcomplete messages with less words
	for i := 0; i < countMessages; i++ {
		msgLength := len(messages[i])
		if countWords > msgLength {
			partialMessage := make([]string, countWords-msgLength)
			messages[i] = append(partialMessage, messages[i]...)
		}
	}

	// initializes the fulle message
	fullMessage := make([]string, countWords)
	for i := 0; i < countMessages; i++ {
		for j := 0; j < countWords; j++ {
			// checks if fullMessage is empty at position message and
			if len(fullMessage[j]) == 0 && len(messages[i][j]) != 0 {
				// compies word to fullMessage
				fullMessage[j] = messages[i][j]
			} else if (len(fullMessage[j]) > 0 && len(messages[i][j]) > 0) && (fullMessage[j] != messages[i][j]) {
				return completeMessage, fmt.Errorf("the words at position %d mismatch between full an partial messages. Has %s and in teh partial message is %s", j, fullMessage[j], messages[i][j])
			}
		}
	}
	completeMessage = strings.Join(fullMessage, " ")
	return completeMessage, nil
}
