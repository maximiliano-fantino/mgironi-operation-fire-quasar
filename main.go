package main

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"log"

	"regexp"

	"strconv"

	"github.com/mgironi/operation-fire-quasar/location"

	"github.com/mgironi/operation-fire-quasar/message"
)

func main() {
	log.SetFlags(0)
	if AskForHelp() {
		return
	}

	log.Println("program initiated.")
	distances, _, parseErr := ParseArgs()
	if parseErr != nil {
		log.Println("ERROR")
		log.Fatal(parseErr)
	}
	x, y := GetLocation(distances...)
	log.Printf("Result calculation Location coordinates are x: %f, y: %f", x, y)
}

const HELP_PASING_DISTANCES = "Required ordered list of distances to each satelite Kenobi,Skywalker,Sato.\n\t\tPlease use keyword 'distances', '=' and coma ',' as list separator values.\n\t\texample: cmd -distances=100,230.5,403"

func AskForHelp() (askedForHelp bool) {
	cmdArgs := os.Args
	helpArgRegex := regexp.MustCompile(`(-h)|(help)`)
	askedForHelp = false
	for _, arg := range cmdArgs {
		//checks if asking for help
		if helpArgRegex.MatchString(arg) {
			log.Println("Hello to Operation Fire Quasar.")
			log.Print("\nUsage:\n")
			log.Print("\n\toperation-fire-quasar <arguments>\n")
			log.Print("\nThe arguments are:\n")
			log.Print("\n\t-distances\n")
			log.Print("\t\t" + HELP_PASING_DISTANCES + "\n")
			log.Print("\nexamples:\n")
			log.Print("\n\toperation-fire-quasar -distances=100,200.65,-300.47\n")
			askedForHelp = true
		}
	}
	return askedForHelp
}

func ParseArgs() (distances []float32, messages []string, err error) {
	cmdArgs := os.Args
	distancesArgRegex := regexp.MustCompile(`\bdistances\b`)
	//messagesArgRegex := regexp.MustCompile(`\bmessages\b`)
	for i, arg := range cmdArgs {
		if i == 0 {
			continue
		}
		if distancesArgRegex.MatchString(arg) {
			//gets separator '=' idx
			separatorIdx := strings.Index(arg, "=")
			if separatorIdx > 0 {
				// split distances list values strings
				values := strings.Split(arg[separatorIdx+1:], ",")

				// checks if at least have 3 values
				if len(values) < 3 {
					return distances, messages, fmt.Errorf("error parsing distances, list values count: %d. Need 3 at least", len(values))
				}

				// intializes disntances
				distances = make([]float32, len(values))

				// parse values
				for i, value := range values {
					// parse value to float
					valueFloat, parseErr := strconv.ParseFloat(value, 32)
					if parseErr != nil {
						return distances, messages, fmt.Errorf("error parsing distances, list value: %s . %e", values, parseErr)
					}
					// convert to float32
					distances[i] = float32(valueFloat)
				}
			}
		}
	}

	// checks if distances was populated
	if len(distances) == 0 {
		// no parseable values for distances detected
		return distances, messages, errors.New("no parseable values for distances argument detected.\n\t\t" + HELP_PASING_DISTANCES)
	}

	/*if len(messages) == 0 {
		// no parseable values for messages detected
		return distances, messages, errors.New("No parseable values for messages arg detected. Please use '=' and coma ';' as list separator messages and coma ',' to word separator (don't use empty spaces just ,,) and ex: cmd -message=this,,the,message,complete;,is,the,,complete;,is,,messge,complete...")
	}*/
	return distances, messages, nil
}

// input: distance to the transmitter recieved on each satlelite
// output: the coordinates 'x' and 'y' of the message emiter
func GetLocation(distances ...float32) (x, y float32) {
	if len(distances) < 3 {
		log.Printf("There is not enough distances values as parameter to determine location. At least 3 distances are required ")
	}
	var err error
	x, y, err = location.CalculateLocation(distances)
	if err != nil {
		log.Printf("%e", err)
	}
	return x, y
}

// input: the message as it is recieved on each satelite
// output: the message as it is generated by the transmitter
func GetMessage(messages ...[]string) (msg string) {
	return message.ConsolidateMessage(messages)
}
